
/*
* pose landmark index
    0 PoseLandmark.NOSE,
    1 PoseLandmark.LEFT_EYE,
    2 PoseLandmark.RIGHT_EYE,
    3 PoseLandmark.LEFT_EAR,
    4 PoseLandmark.RIGHT_EAR,
    5 PoseLandmark.LEFT_SHOULDER,
    6 PoseLandmark.RIGHT_SHOULDER,
    7 PoseLandmark.LEFT_ELBOW,
    8 PoseLandmark.RIGHT_ELBOW,
    9 PoseLandmark.LEFT_WRIST,
    10 PoseLandmark.RIGHT_WRIST,
    11 PoseLandmark.LEFT_HIP,
    12 PoseLandmark.RIGHT_HIP,
    13 PoseLandmark.LEFT_KNEE,
    14 PoseLandmark.RIGHT_KNEE,
    15 PoseLandmark.LEFT_ANKLE,
    16 PoseLandmark.RIGHT_ANKLE

* pose landmark Unit List
    x, y, class, confidence
 */


import { Alert } from "react-native";

const PoseLandmark = {
    NOSE: 0,
    LEFT_EYE: 1,
    RIGHT_EYE: 2,
    LEFT_EAR: 3,
    RIGHT_EAR: 4,
    LEFT_SHOULDER: 5,
    RIGHT_SHOULDER: 6,
    LEFT_ELBOW: 7,
    RIGHT_ELBOW: 8,
    LEFT_WRIST: 9,
    RIGHT_WRIST: 10,
    LEFT_HIP: 11,
    RIGHT_HIP: 12,
    LEFT_KNEE: 13,
    RIGHT_KNEE: 14,
    LEFT_ANKLE: 15,
    RIGHT_ANKLE: 16
}

const CamType = {
    FRONT: 0,
    LEFT: 1,
    RIGHT: 2,
    BACK: 3
}

class Coordinate {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static subtract(a, b) {
        return new Coordinate(a.x-b.x, a.y-b.y);
    }

    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
    }

    static dot(a, b) {
        const ddx = a.x * b.x;
        const ddy = a.y * b.y;
        return new Coordinate(ddx, ddy);
    }
}

class bodyShapeAnalyzer {

    constructor(keyPointsList) {

        this.keyPointsList = keyPointsList;w

        // 각 항목의 각도 산출 호출
        this.turtleNeckAnalAngle = this.checkTurtleNeck();
        this.shoulderBalanceAnalAngle = this.checkShoulderBalance();

        const [lPelvisAnalAngle, rPelvisAnalAngle] = this.checkPelvis();
        this.lPelvisAnalAngle = lPelvisAnalAngle;
        this.rPelvisAnalAngle = rPelvisAnalAngle;

        const [lOXLegAnalAngle, rOXLegAnalAngle] = this.checkOXLeg();
        this.lOXLegAnalAngle = lOXLegAnalAngle;
        this.rOXLegAnalAngle = rOXLegAnalAngle;


    }//.constructor

    /**
     * 세 점을 입력받아 내각을 구하는 함수. 제2코사인법칙 활용
     * @param {*} a 시작점
     * @param {*} b 중앙점(각도점)
     * @param {*} c 끝점
     * @returns 각도(degree)
     */
    _getAngle(a, b, c) {
        const AB = Coordinate.distance(a, b);
        const BC = Coordinate.distance(b, c);
        const CA = Coordinate.distance(c, a);
        const cosB = ((AB**2 + BC**2 - CA**2) / (2 * AB * BC)).toFixed(5);
        return Math.acos(cosB) * (180 / Math.PI);
    }


    /*
        골반균형
        - 정면사진 활용
        - 어깨균형과 유사
        - 양쪽 귀 점을 지나는 직선을 기준직선이라 함
        - 양쪽 골반 점을 지나는 직선을 판단직선이라 함
        - 기준직선과 판단직선의 각도가 5도 이상이면 골반불균형으로 판단
        - 좌-골반불균형과 우-골반불균형은 각 골반과 귀 사이의 거리를 기준으로 함(좌-골반불균형은 기준직선과 판단직선의 각도가 5도 이상이면서 왼쪽골반과 왼쪽귀 사이의 거리가 오른쪽골반과 오른쪽 귀 사이의 거리보다 짧음)
     */
    checkPelvis() {
        const frontKeyPoints = this.keyPointsList.find((keyPoints) => keyPoints.id == CamType.FRONT).keyPoints;
        const origin = new Coordinate(0, 0);
        const LEar = new Coordinate(frontKeyPoints[3*4], frontKeyPoints[3*4+1]);
        const REar = new Coordinate(frontKeyPoints[4*4], frontKeyPoints[4*4+1]);
        const LHip = new Coordinate(frontKeyPoints[11*4], frontKeyPoints[11*4+1]);
        const RHip = new Coordinate(frontKeyPoints[12*4], frontKeyPoints[12*4+1]);

        // 좌측 골반각도 구하기
        let stdLine = Coordinate.subtract(REar, LEar);
        let targetLine = Coordinate.subtract(RHip, LHip);
        const lPelvisAngle = this._getAngle(stdLine, origin, targetLine);

        // 우측 골반각도 구하기
        stdLine = Coordinate.subtract(LEar, REar);
        targetLine = Coordinate.subtract(LHip, RHip);
        const rPelvisAngle = this._getAngle(stdLine, origin, targetLine);

        return [lPelvisAngle, rPelvisAngle];
    }

    /*
    OX다리
        - 정면사진 활용. Q-angle참고.
        - 골반(a),무릎(b),발목(c)를 삼각형으로 하여 각abc로 판단
        - 각abc<160: X다리
        - 160<각abc<165: 정상
        - 170<각abc: O다리
     */
    checkOXLeg() {
        // OX 다리
        const frontKeyPoints = this.keyPointsList.find((keyPoints) => keyPoints.id == CamType.FRONT).keyPoints;
        const LHip = new Coordinate(frontKeyPoints[11*4], frontKeyPoints[11*4+1]);
        const LKnee = new Coordinate(frontKeyPoints[13*4], frontKeyPoints[13*4+1]);
        const LAnkle = new Coordinate(frontKeyPoints[15*4], frontKeyPoints[15*4+1]);

        const RHip = new Coordinate(frontKeyPoints[12*4], frontKeyPoints[12*4+1]);
        const RKnee = new Coordinate(frontKeyPoints[14*4], frontKeyPoints[14*4+1]);
        const RAnkle = new Coordinate(frontKeyPoints[16*4], frontKeyPoints[16*4+1]);

        const LAngle = this._getAngle(LHip, LKnee, LAnkle);
        const RAngle = this._getAngle(RHip, RKnee, RAnkle);

        return [LAngle, RAngle];
    }

    /*
       거북목 측정
       - 측면사진 활용 (
       - 귀(a),어깨(b),발목(c)을 삼각형으로 하여 내각이 170도보다 작으면 거북목 크면 정상
     */
    checkTurtleNeck() {
        const leftKeyPoints = this.keyPointsList.find((keyPoints) => keyPoints.id === CamType.LEFT).keyPoints;
        const rightKeyPoints = this.keyPointsList.find((keyPoints) => keyPoints.id === CamType.RIGHT).keyPoints;

        const LEar = new Coordinate(leftKeyPoints[3 * 4], leftKeyPoints[3 * 4 + 1]);
        const LShoulder = new Coordinate(leftKeyPoints[5 * 4], leftKeyPoints[5 * 4 + 1]);
        const LAnkle = new Coordinate(leftKeyPoints[15 * 4], leftKeyPoints[15 * 4 + 1]);

        const REar = new Coordinate(rightKeyPoints[4 * 4], rightKeyPoints[4 * 4 + 1]);
        const RShoulder = new Coordinate(rightKeyPoints[6 * 4], rightKeyPoints[6 * 4 + 1]);
        const RAnkle = new Coordinate(rightKeyPoints[16 * 4], rightKeyPoints[16 * 4 + 1]);

        const LAngle = this._getAngle(LEar, LShoulder, LAnkle);
        const RAngle = this._getAngle(REar, RShoulder, RAnkle);

        console.log("checkTurtleNeck - LAngle: ", LAngle, "RAngle: ", RAngle);

        // 좌측과 추측 각도의 평균 (일단 평균으로)
        const avgAngle = (LAngle + RAngle) / 2;

        return avgAngle;
    }

    /*
        어깨균형
        - 정면사진 활용
        - 양쪽 귀 점을 지나는 직선을 기준직선이라 함
        - 양쪽 어깨 점을 지나는 직선을 판단직선이라 함
        - 기준직선과 판단직선의 각도가 5도 이상이면 어깨불균형으로 판단
        - 좌-어깨불균형과 우-어께불균형은 각 어깨와 귀 사이의 거리를 기준으로 함(좌-어께불균형은 기준직선과 판단직선의 각도가 5도 이상이면서 왼쪽어깨와 왼쪽귀 사이의 거리가 오른쪽어깨와 오른쪽 귀 사이의 거리보다 짧음)
     */
    checkShoulderBalance() {
        const frontKeyPoints = this.keyPointsList.find((keyPoints) => keyPoints.id === CamType.FRONT).keyPoints;
        const LEar = new Coordinate(frontKeyPoints[3 * 4], frontKeyPoints[3 * 4 + 1]);
        const REar = new Coordinate(frontKeyPoints[4 * 4], frontKeyPoints[4 * 4 + 1]);
        const LShoulder = new Coordinate(frontKeyPoints[5 * 4], frontKeyPoints[5 * 4 + 1]);
        const RShoulder = new Coordinate(frontKeyPoints[6 * 4], frontKeyPoints[6 * 4 + 1]);

        const stdLine = Coordinate.subtract(LEar, REar);
        const targetLine = Coordinate.subtract(LShoulder, RShoulder);
        const angle = this._getAngle(stdLine, new Coordinate(0, 0), targetLine);

        return angle;
    }




}

export default bodyShapeAnalyzer;